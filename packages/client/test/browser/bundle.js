import{createEncoder as e,deepEqual as t}from"@saulx/utils";import*as s from"fflate";import{applyPatch as n}from"@saulx/diff";import{hash as o,hashObjectIgnoreKeyOrder as r}from"@saulx/hash";import i from"@based/opts";import a from"isomorphic-ws";const c=e=>{try{const t=global.atob(decodeURI(e));return JSON.parse(t)}catch(e){return{error:"Invalid authState"}}},{encode:l}=e(["(",")","<",">","@",",",";",":","\\",'"',"/","[","]","?","=","{","}"," "],["0"]),h=e=>encodeURI(l(global.btoa(String.fromCodePoint(...(new TextEncoder).encode(JSON.stringify(e))))));var u;!function(e){e[e.FunctionError=50001]="FunctionError",e[e.AuthorizeFunctionError=50002]="AuthorizeFunctionError",e[e.NoOservableCacheAvailable=50003]="NoOservableCacheAvailable",e[e.ObservableFunctionError=50004]="ObservableFunctionError",e[e.ObserveCallbackError=50005]="ObserveCallbackError",e[e.FunctionNotFound=40401]="FunctionNotFound",e[e.FunctionIsNotObservable=40402]="FunctionIsNotObservable",e[e.FunctionIsObservable=40403]="FunctionIsObservable",e[e.FunctionIsStream=40404]="FunctionIsStream",e[e.CannotStreamToObservableFunction=40405]="CannotStreamToObservableFunction",e[e.AuthorizeRejectedError=40301]="AuthorizeRejectedError",e[e.InvalidPayload=40001]="InvalidPayload",e[e.PayloadTooLarge=40002]="PayloadTooLarge",e[e.ChunkTooLarge=40003]="ChunkTooLarge",e[e.UnsupportedContentEncoding=40004]="UnsupportedContentEncoding",e[e.NoBinaryProtocol=40005]="NoBinaryProtocol",e[e.LengthRequired=41101]="LengthRequired",e[e.MethodNotAllowed=40501]="MethodNotAllowed",e[e.RateLimit=40029]="RateLimit",e[e.MissingAuthStateProtocolHeader=40030]="MissingAuthStateProtocolHeader",e[e.IncorrectAccessKey=40031]="IncorrectAccessKey"}(u=u||(u={}));class d extends Error{}const f=(e,t)=>{if(!e||"object"!=typeof e){const t=new d(`Payload: ${e}`);return t.name="Invalid returned payload",t}const{message:s,code:n}=e,o=s?"["===s[0]?s:`[${u[n]}] `+s:n?"Cannot read error msg":JSON.stringify(e,null,2),r=new d(o);return r.stack=t?o+" "+t:o,r.name=u[n],r.code=n,r},g=new Map;let b;"undefined"!=typeof document&&document.addEventListener("visibilitychange",function(){clearTimeout(b),document.hidden?b=setTimeout(()=>{g.forEach(e=>{e(!1)})},3e4):g.forEach(e=>{e(!0)})});const m=(e,t,s={destroy:()=>{g.delete(s)}},n=0,o=!1)=>(((e,t)=>{"function"==typeof e?e().then(e=>{t(e)}):t(e)})(t,r=>{setTimeout(()=>{if(s.disconnected)return;let i=!0;g.set(s,n=>{s.disconnected||(!n&&i?e.functionResponseListeners.size?(console.warn("Send to background - streams or functions in progress try again in 10 seconds..."),clearTimeout(b),b=setTimeout(()=>{g.forEach(e=>{e(!1)})},1e4)):(console.warn("Send to background - close connection"),i=!1,e.onClose(),c.close()):!i&&n&&(g.delete(s),m(e,t,s,0,!0)))});const c=s.ws=new a(r,[h(e.authState)]);let l=!1;c.binaryType="blob",c.addEventListener("error",e=>{e.message&&e.message.includes("401")&&(l=!0)}),c.addEventListener("message",t=>{e.onData(t)}),c.addEventListener("open",()=>{if(i){if(s.disconnected)return;n=100,o&&e.onReconnect(),e.onOpen()}}),c.addEventListener("close",()=>{if(i){if(s.disconnected)return;e.onClose(),m(e,t,s,l?5e3:Math.min(2500,n+~~(500*Math.random())+100),!0)}})},n)}),s);class S{constructor(){this.listeners={},Object.defineProperty(this,"listeners",{enumerable:!1,writable:!0})}emit(e,t){if(this.listeners[e]){const s=this.listeners[e];for(let e=0,n=s.length;e<s.length;e++){const o=s[e];o(t),n>s.length&&s[e]!==o&&(e--,n=s.length)}}}on(e,t){this.listeners[e]||(this.listeners[e]=[]),this.listeners[e].push(t)}removeAllListeners(){this.listeners={}}once(e,t){if(!t)return new Promise(t=>{const s=n=>{t(n),this.off(e,s)};this.on(e,s)});const s=n=>{t(n),this.off(e,s)};this.on(e,s)}off(e,t){const s=this.listeners[e];if(s)if(t){for(let e=0;e<s.length;e++)if(s[e]===t){s.splice(e,1),e--;break}0===s.length&&delete this.listeners[e]}else delete this.listeners[e]}}const p=new TextDecoder,v=new TextEncoder,y=(e,t)=>{const s=localStorage.getItem(t);s&&(e.storageSize-=new Blob([s]).size,localStorage.setItem("@based-size",String(e.storageSize)),localStorage.removeItem(t))},w=()=>{const e=Object.keys(localStorage);try{for(const t of e)t.startsWith("@based")&&localStorage.removeItem(t)}catch(e){try{localStorage.clear()}catch(e){console.error("Based - Error clearing localStorage")}}},E=(e,t,n)=>{try{const o=e.storageEnvKey;if(!o)return;const r=localStorage.getItem(t),i=JSON.stringify(n),a=i.length>70||t==="@based-authState-"+o?global.btoa(p.decode(s.deflateSync(v.encode(i)))):i,c=new Blob([a]).size;r&&(e.storageSize-=new Blob([r]).size),e.storageSize+=c,e.storageSize>e.maxStorageSize&&(console.info("Based - Max localStorage size reached - clear"),w(),e.storageSize=0,!0===e.authState.persistent&&E(e,"@based-authState-"+o,e.authState),e.storageSize+=c),localStorage.setItem("@based-size",String(e.storageSize)),localStorage.setItem(t,a)}catch(e){console.error(`Based - Error writing ${t} to localStorage`,e)}},T=(e,t)=>{const n=e.storageEnvKey;if(n)try{const e=localStorage.getItem(t);if(void 0!==e){if(e.length<70&&t!=="@based-authState-"+n)try{return JSON.parse(e)}catch(e){}return(e=>{const t=global.atob(e),n=p.decode(s.inflateSync(v.encode(t)));return JSON.parse(n)})(e)}return}catch(e){console.error(`Based - Error parsing ${t} from localStorage`)}},I="undefined"!=typeof window,Q=(e,t)=>{const s=e.storageEnvKey;s&&I&&y(e,t+="-"+s)},C=(e,t,s)=>{const n=e.storageEnvKey;n&&I&&E(e,t+="-"+n,s)},z=async e=>{},R=(e,t)=>{t.persistent?C(e,"@based-authState",t):Q(e,"@based-authState"),e.authState=t},q=new TextEncoder,O=(e,t,s,n)=>{for(let o=s;o<s+n;o++){const s=255&t;e[o]=s,t=(t-s)/256}},P=(e,t,s,n=s)=>{const o=((e,t,s)=>(e<<1)+(0|t)+(s<<4))(e,t,s),r=new Uint8Array(n);return O(r,o,0,4),r},N=(e,t=!1)=>{let n,o=!1;return void 0!==e?(n=q.encode("string"==typeof e?e:JSON.stringify(e)),!t&&n.length>150&&(n=s.deflateSync(n),o=!0),[o,n]):[!1]},L=(e,t)=>{let s=4;const[n,o,r,i]=t;if(3===n){const t=q.encode(o);s+=1+t.length;const[a,c]=N(i);c&&(s+=c.length);const l=16;s+=l;const h=P(n,a,s,5+l);return O(h,e,4,8),O(h,r,12,8),h[20]=t.length,c?{buffers:[h,t,c],len:s}:{buffers:[h,t],len:s}}return{buffers:[],len:0}},A=(e,t)=>{let s=4;const[n,o,r]=t;if(7===n){const t=P(n,!1,12);return O(t,e,4,8),{buffers:[t],len:12}}const i=q.encode(o);s+=1+i.length;const a=6===n,[,c]=N(r,!0);c&&(s+=c.length),s+=8;const l=P(5,a,s,13);return O(l,e,4,8),l[12]=i.length,c?{buffers:[l,i,c],len:s}:{buffers:[l,i],len:s}},M=(e,t)=>{let s=4;const[n,o,r,i]=t;if(2===n){const t=P(n,!1,12);return O(t,e,4,8),{buffers:[t],len:12}}const a=q.encode(o);s+=1+a.length;const[c,l]=N(i);l&&(s+=l.length),s+=16;const h=P(n,c,s,21);return O(h,e,4,8),O(h,r,12,8),h[20]=a.length,l?{buffers:[h,a,l],len:s}:{buffers:[h,a],len:s}},B=e=>{let t=7;const[s,n,o]=e,r=q.encode(n);t+=1+r.length;const[i,a]=N(o);a&&(t+=a.length);const c=P(0,i,t,8);return O(c,s,4,3),c[7]=r.length,a?{buffers:[c,r,a],len:t}:{buffers:[c,r],len:t}},k=e=>{let t=12;const[s,n]=e,[o,r]=N(n);r&&(t+=r.length);const i=P(6,o,t,12);return O(i,s,4,8),r?{buffers:[i,r],len:t}:{buffers:[i],len:t}},x=new Uint8Array(0),F=e=>!!(e.fQ.length||e.oQ.size||e.gQ.size||e.cQ.size||e.pQ.length),J=e=>{if(e.connected&&!e.drainInProgress&&F(e)){e.drainInProgress=!0;const t=()=>{if(e.drainInProgress=!1,e.connected&&F(e)){const t=e.cQ,s=e.pQ,n=e.fQ,o=e.oQ,r=e.gQ,i=[];let a=0;for(const[e,s]of t){const{buffers:t,len:n}=A(e,s);i.push(...t),a+=n}for(const[e,t]of r){const{buffers:s,len:n}=L(e,t);i.push(...s),a+=n}for(const[e,t]of o){const{buffers:s,len:n}=M(e,t);i.push(...s),a+=n}for(const e of n){const{buffers:t,len:s}=B(e);i.push(...t),a+=s}for(const e of s){const{buffers:t,len:s}=k(e);i.push(...t),a+=s}const c=new Uint8Array(a);let l=0;for(const e of i)c.set(e,l),l+=e.length;e.fQ=[],e.pQ=[],e.oQ.clear(),e.gQ.clear(),e.cQ.clear(),e.connection.ws.send(c),(e=>{clearTimeout(e.idlePing),e.idlePing=setTimeout(()=>{e.connection&&e.connected&&!e.connection.disconnected&&e.connection.ws.send(x)},6e4)})(e)}};e.drainTimeout=setTimeout(t,0)}},j=(e,t,s,n,o)=>{e.requestId++,e.requestId>16777215&&(e.requestId=0);const r=e.requestId,i=Error().stack.split(/BasedClient\.function.+:\d\d\)/)[1];e.functionResponseListeners.set(r,[n,o,i]),e.fQ.push([r,s,t]),J(e)},D=(e,t,s,n)=>{var o;5!==(null==(o=e.cQ.get(s))?void 0:o[0])&&(e.cQ.set(s,[5,t,n]),J(e))},U=(e,t,s,n)=>{var o;const r=null==(o=e.cQ.get(s))?void 0:o[0];5!==r&&6!==r&&(e.cQ.set(s,[6,t,n]),J(e))},K=(e,t,s,n,o=0)=>{var r;1!==(null==(r=e.oQ.get(s))?void 0:r[0])&&(e.oQ.set(s,[1,t,o,n]),J(e))},_=(e,t,s,n,o=0)=>{e.gQ.has(s)||(e.gQ.set(s,[3,t,o,n]),J(e))},$=async(e,s)=>t(s,e.authState)?(console.warn("[Based] Trying to send the same authState twice",e.authState),e.authRequest.inProgress?e.authRequest.promise:new Promise(e=>e({}))):(e.authRequest.inProgress&&(console.warn("[Based] Authentication still in progress - waiting until done"),await e.authRequest.promise),R(e,s),e.emit("authstate-change",e.authState),e.connected&&e.connection.ws.send((e=>{let t=4;const[s,n]=N(e);n&&(t+=n.length);const o=P(4,s,t);return n&&o.set(n,4),o})(s)),e.authRequest.promise=new Promise((t,s)=>{e.authRequest.inProgress=!0,e.authRequest.resolve=t,e.authRequest.reject=s}).finally(()=>{e.authRequest.resolve=null,e.authRequest.reject=null,e.authRequest.inProgress=!1}),e.authRequest.promise),W=(e,t,s)=>{let n=0;for(let o=s-1+t;o>=t;o--)n=256*n+e[o];return n},H=(e,t)=>{const s=e.observeState.get(t);_(e,s.name,t,s.payload)},G=(e,t,s)=>{const n="sub"===s?e.observeState.get(t):e.channelState.get(t);return n?n.payload?{name:n.name,payload:n.payload,id:t}:{name:n.name,id:t}:{name:`[Cannot find ${t}]`,id:t}},V=(e,t,n,o)=>(new TextDecoder).decode(n?s.inflateSync(o.slice(e,t)):o.slice(e,t)),X=(e,t)=>void 0===t?o(e):r([e,t]);class Y{constructor(e,t,s,n){this.query=s,this.id=X(t,s),this.client=e,this.name=t,this.persistent=(null==n?void 0:n.persistent)||!1}get cache(){return this.client.cache.get(this.id)||null}clearCache(){this.persistent&&Q(this.client,"@based-cache-"+this.id),this.client.cache.delete(this.id)}subscribe(e,t){let s;const n=this.client.cache.get(this.id);if(this.client.observeState.has(this.id)){const o=this.client.observeState.get(this.id);this.persistent&&!o.persistent&&(o.persistent=!0,n&&C(this.client,"@based-cache-"+this.id,n)),s=++o.idCnt,o.subscribers.set(s,{onError:t,onData:e})}else{s=1;const o=new Map;o.set(s,{onError:t,onData:e}),this.client.observeState.set(this.id,{payload:this.query,name:this.name,subscribers:o,persistent:this.persistent||!1,idCnt:1}),K(this.client,this.name,this.id,this.query,(null==n?void 0:n.checksum)||0)}return n&&e(n.value,n.checksum),()=>{const e=this.client.observeState.get(this.id);var t,n,o;e?(e.subscribers.delete(s),0===e.subscribers.size&&(this.client.observeState.delete(this.id),2!==(null==(o=(t=this.client).oQ.get(n=this.id))?void 0:o[0])&&(t.oQ.set(n,[2]),J(t)))):console.warn("Subscription allready removed",this.query,this.name)}}async getWhen(e){return new Promise(t=>{const s=this.subscribe((n,o)=>{e(n,o)&&(t(n),s())})})}async get(){return new Promise((e,t)=>{if(this.client.getState.has(this.id))return void this.client.getState.get(this.id).push([e,t]);this.client.getState.set(this.id,[]);const s=this.client.cache.get(this.id);if(this.client.observeState.has(this.id)){if(this.client.oQ.has(this.id)){const[s]=this.client.oQ.get(this.id);if(1===s)return void this.client.getState.get(this.id).push([e,t])}if(s)return void e(s.value)}this.client.getState.get(this.id).push([e,t]),_(this.client,this.name,this.id,this.query,(null==s?void 0:s.checksum)||0)})}}const Z=e=>{e.channelCleanTimeout||(e.channelCleanTimeout=setTimeout(()=>{if(e.channelCleanTimeout=null,e.connected){let t=!1;e.channelState.forEach((s,n)=>{-1!==s.removeTimer&&(s.removeTimer--,0===s.removeTimer?e.channelState.delete(n):t=!0)}),t&&Z(e)}else Z(e)},e.channelCleanupCycle))};class ee{constructor(e,t,s){this.payload=s,this.id=X(t,s),this.client=e,this.name=t}subscribe(e,t){let s;if(this.client.channelState.has(this.id)&&0!==this.client.channelState.get(this.id).subscribers.size){const n=this.client.channelState.get(this.id);n.removeTimer=-1,s=++n.idCnt,n.subscribers.set(s,{onMessage:e,onError:t})}else{s=1;const n=new Map;n.set(s,{onMessage:e,onError:t}),this.client.channelState.set(this.id,{payload:this.payload,name:this.name,subscribers:n,removeTimer:-1,idCnt:1}),D(this.client,this.name,this.id,this.payload)}return()=>{const e=this.client.channelState.get(this.id);var t,n,o;e.subscribers.delete(s),0===e.subscribers.size&&(e.removeTimer=2,7!==(null==(o=(t=this.client).cQ.get(n=this.id))?void 0:o[0])&&(t.cQ.set(n,[7]),J(t)))}}publish(e){if(this.client.channelState.has(this.id)){const e=this.client.channelState.get(this.id);-1!==e.removeTimer&&e.removeTimer<2&&(e.removeTimer=2,Z(this.client))}else this.client.channelState.set(this.id,{payload:this.payload,name:this.name,subscribers:new Map,removeTimer:2,idCnt:0}),Z(this.client),U(this.client,this.name,this.id,this.payload);var t,s,n;s=this.id,n=e,(t=this.client).pQ.length>t.maxPublishQueue&&t.pQ.shift(),t.pQ.push([s,n]),J(t)}}const te=i.default;class se extends S{constructor(e,t){super(),this.storageSize=0,this.maxStorageSize=4999500,this.storageEnvKey=0,this.connected=!1,this.outgoingStreams=new Map,this.isDrainingStreams=!1,this.maxPublishQueue=1e3,this.pQ=[],this.fQ=[],this.oQ=new Map,this.cQ=new Map,this.gQ=new Map,this.drainInProgress=!1,this.localStorage=!1,this.maxCacheSize=4e6,this.cache=new Map,this.functionResponseListeners=new Map,this.requestId=0,this.channelState=new Map,this.channelCleanupCycle=3e4,this.observeState=new Map,this.getState=new Map,this.authState={},this.authRequest={authState:null,promise:null,resolve:null,reject:null,inProgress:!1},null!=t&&t.persistentStorage&&(this.storagePath=t.persistentStorage),null!=t&&t.maxCacheSize&&(console.warn("MaxCacheSize setting not implemented yet..."),this.maxCacheSize=t.maxCacheSize),e&&this.connect(e)}onClose(){this.connected=!1,this.functionResponseListeners.size>this.fQ.length&&this.functionResponseListeners.forEach((e,t)=>{this.fQ.find(([e])=>e===t)||(e[1](new Error("Server disconnected before function result was processed")),this.functionResponseListeners.delete(t))}),this.emit("disconnect",!0)}onReconnect(){this.connected=!0,this.emit("reconnect",!0)}onOpen(){this.connected=!0,this.emit("connect",!0);for(const[e,t]of this.observeState)if(!this.oQ.has(e)){const s=this.cache.get(e);K(this,t.name,e,t.payload,(null==s?void 0:s.checksum)||0)}for(const[e,t]of this.channelState)this.cQ.has(e)||(t.subscribers.size?D(this,t.name,e,t.payload):U(this,t.name,e,t.payload));J(this)}onData(e){(async(e,s)=>{if(!e.isDestroyed)try{const r=s.data,i=await(async e=>{if(e instanceof ArrayBuffer)return new Uint8Array(e);if("undefined"==typeof window){if(e instanceof Buffer)return new Uint8Array(e)}else if(e instanceof Blob){const t=await e.arrayBuffer();return new Uint8Array(t)}throw new Error("432")})(r),{type:a,len:c,isDeflate:l}=(e=>{const t=15&e;return{type:t>>1,isDeflate:1==(1&t),len:e>>4}})(W(i,0,4));if(0===a){const t=W(i,4,3);let s;3!==c&&(s=JSON.parse(V(7,c+4,l,i))),e.functionResponseListeners.has(t)&&(e.functionResponseListeners.get(t)[0](s),e.functionResponseListeners.delete(t))}else if(3===a){const t=W(i,4,8);if(e.getState.has(t)&&e.cache.has(t)){const s=e.getState.get(t);for(const[n]of s)n(e.cache.get(t).value);e.getState.delete(t)}}else if(2===a){const t=W(i,4,8),s=e.cache.get(t);if(!s)return void H(e,t);const o=W(i,12,8),r=W(i,20,8);if(s.checksum!==r)return void H(e,t);let a;24!==c&&(a=JSON.parse(V(28,c+4,l,i)));try{s.value=n(s.value,a),s.checksum=o}catch(s){return void H(e,t)}if(e.observeState.has(t)){const n=e.observeState.get(t);n.persistent&&(s.persistent=!0,C(e,"@based-cache-"+t,s));for(const[,e]of n.subscribers)e.onData(s.value,o)}if(e.getState.has(t)){const n=e.getState.get(t);for(const[e]of n)e(s.value);e.getState.delete(t)}}else if(1===a){const t=W(i,4,8),s=W(i,12,8);let n;16!==c&&(n=JSON.parse(V(20,c+4,l,i)));const o={value:n,checksum:s};if(e.cache.set(t,o),e.observeState.has(t)){const r=e.observeState.get(t);r.persistent&&(o.persistent=!0,C(e,"@based-cache-"+t,o));for(const[,e]of r.subscribers)e.onData(n,s)}if(e.getState.has(t)){const s=e.getState.get(t);for(const[e]of s)e(n);e.getState.delete(t)}}else if(4===a){let s;if(3!==c&&(s=JSON.parse(V(4,c+4,l,i))),!0===s)null==e.authRequest.resolve||e.authRequest.resolve(e.authState);else if("error"in s)R(e,s),e.emit("authstate-change",e.authState),null==e.authRequest.reject||e.authRequest.reject(new Error(s.error));else{var o;t(e.authState,s)?R(e,s):(R(e,s),e.emit("authstate-change",e.authState)),null==(o=e.authRequest)||null==o.resolve||o.resolve(e.authState)}}else if(5===a){let t;if(3!==c&&(t=JSON.parse(V(4,c+4,l,i))),t.requestId&&e.functionResponseListeners.has(t.requestId)){const[,s,n]=e.functionResponseListeners.get(t.requestId);s(f(t,n)),e.functionResponseListeners.delete(t.requestId)}if(t.channelId&&e.channelState.has(t.channelId)){const s=f(t),n=e.channelState.get(t.channelId);for(const[,o]of n.subscribers)o.onError?o.onError(s):console.error(G(e,t.channelId,"channel"),s)}if(t.observableId){if(e.cache.delete(t.observableId),e.observeState.has(t.observableId)){const s=f(t),n=e.observeState.get(t.observableId);for(const[,o]of n.subscribers)o.onError?o.onError(s):console.error(G(e,t.observableId,"sub"),s)}if(e.getState.has(t.observableId)){const s=f(t),n=e.getState.get(t.observableId);for(const[,e]of n)e(s);e.getState.delete(t.observableId)}}}else if(6===a){const t=W(i,4,8),s=e.channelState.get(t);if(t){if(!s.inTransit){s.inTransit=!0;const{buffers:n,len:o}=A(t,[6,s.name,s.payload]),r=new Uint8Array(o);let i=0;for(const e of n)r.set(e,i),i+=e.length;e.connection.ws.send(r),-1!==s.removeTimer&&s.removeTimer<2&&(s.removeTimer+=1),setTimeout(()=>{const s=e.channelState.get(t);s&&(s.inTransit=!1)},5e3)}e.connection.ws.send(i)}}else if(7===a&&0===W(i,4,1)){const t=W(i,5,8);let s;if(9!==c){const e=V(13,c+5,l,i);try{s=JSON.parse(e)}catch(t){s=e}}if(e.channelState.has(t)){const n=e.channelState.get(t);for(const[,e]of n.subscribers)e.onMessage(s)}}}catch(e){console.error(981,e)}})(this,e)}async connect(e){if(e&&Object.keys(e).length>0){if(this.opts){if(t(this.opts,e))return;this.disconnect()}this.opts=e,this.url=()=>te(e),this.storageEnvKey=r(e),(async e=>{I&&(async e=>{var t;const s=e.storageEnvKey;if(!s)return;const n=null!=(t=global.__basedcache__)?t:{};for(const t in n)e.cache.set(Number(t),n[t]);try{let t=Number(localStorage.getItem("@based-size")||0);t<0&&(console.error("Based - Corrupt localStorage (negative size) - clear"),w(),t=0),e.storageSize=t;const n=Object.keys(localStorage);if(1===n.length&&t>0&&(console.error("Based - Corrupt localStorage (size but no keys) - clear",t),w(),t=0),console.info("Based - init localstorage stored "+~~(t/1024)+"kb"),t>0)for(const t of n){if("@based-size"===t||!t.startsWith("@based"))continue;if(t==="@based-authState-"+s){const s=T(e,t);s&&e.setAuthState(s).catch(s=>{console.error(s.message),y(e,t)});continue}const[,n]=t.split("@based-cache-");if(!n)continue;const[o,r]=n.split("-");if(r!==String(s))continue;if(!o){console.warn("Based - clear corrupt localStorage item"),y(e,t);continue}const i=T(e,t);e.cache.set(Number(o),i)}}catch(e){console.error("Based - Cannot read localStorage")}})(this)})()}this.opts?this.url&&!this.connection&&(this.connection=m(this,this.url)):console.error("Configure opts to connect")}disconnect(){this.connection&&(this.connection.disconnected=!0,this.connection.destroy(),this.connection.ws&&this.connection.ws.close(),this.connected&&this.onClose(),delete this.connection),clearTimeout(this.drainTimeout),clearTimeout(this.idlePing),this.connected=!1}async destroy(e){e||await z(),clearTimeout(this.storageBeingWritten),clearTimeout(this.channelCleanTimeout),this.disconnect();for(const e in this)delete this[e];this.isDestroyed=!0}channel(e,t){return new ee(this,e,t)}query(e,t,s){return new Y(this,e,t,s)}call(e,t,s){const n=null==s?void 0:s.retryStrategy;return new Promise(n?s=>{let o=0,r=0;const i=a=>{const c=n(a,o,r);r++,"number"!=typeof c||isNaN(c)||(o=c,0===c?j(this,t,e,s,i):setTimeout(()=>{j(this,t,e,s,i)},c))};return j(this,t,e,s,i)}:(s,n)=>j(this,t,e,s,n))}stream(e,t,s){return(async(e,t,s,n)=>{})()}setAuthState(e){if("object"==typeof e)return $(this,e);throw new Error("Invalid auth() arguments")}clearAuthState(){return $(this,{})}clearStorage(){return(async e=>{if(I)return w()})()}saveStorage(){return z()}genCacheScript(){return`<script>window.__basedcache__=${JSON.stringify(ne(this))}<\/script>`}}const ne=e=>{const t={};return e.cache.forEach((e,s)=>{t[s]=e}),t};function oe(e,t){return new se(e,t)}export{se as BasedClient,d as BasedError,u as BasedErrorCode,Y as BasedQuery,f as convertDataToBasedError,c as decodeAuthState,oe as default,h as encodeAuthState};
//# sourceMappingURL=bundle.js.map
