{"version":3,"file":"bundle.js","sources":["../../dist/src/authState/parseAuthState.js","../../dist/src/types/error.js","../../dist/src/websocket/index.js","../../dist/src/websocket/urlLoader.js","../../dist/src/Emitter.js","../../dist/src/persistentStorage/browser.js","../../dist/src/persistentStorage/index.js","../../dist/src/authState/updateAuthState.js","../../dist/src/outgoing/protocol.js","../../dist/src/outgoing/index.js","../../dist/src/incoming/protocol.js","../../dist/src/getTargetInfo.js","../../dist/src/incoming/index.js","../../dist/src/genObserveId.js","../../dist/src/query/index.js","../../dist/src/channel/cleanUp.js","../../dist/src/channel/index.js","../../dist/src/index.js","../../dist/src/stream/index.js"],"sourcesContent":["import { createEncoder } from '@saulx/utils';\nexport const decodeAuthState = (authState) => {\n    try {\n        const str = global.atob(decodeURI(authState));\n        return JSON.parse(str);\n    }\n    catch (err) {\n        return { error: 'Invalid authState' };\n    }\n};\n/*\n  Websocket Protocol\n      token          = 1*<any CHAR except CTLs or separators>\n      separators     = \"(\" | \")\" | \"<\" | \">\" | \"@\"\n                    | \",\" | \";\" | \":\" | \"\\\" | <\">\n                    | \"/\" | \"[\" | \"]\" | \"?\" | \"=\"\n                    | \"{\" | \"}\" | SP | HT\n      exclude \" | '\n*/\n// | HT (what is this?)\nconst { encode } = createEncoder([\n    '(',\n    ')',\n    '<',\n    '>',\n    '@',\n    ',',\n    ';',\n    ':',\n    '\\\\',\n    '\"',\n    '/',\n    '[',\n    ']',\n    '?',\n    '=',\n    '{',\n    '}',\n    ' ',\n], ['0']);\nexport const encodeAuthState = (authState) => {\n    return encodeURI(encode(global.btoa(String.fromCodePoint(...new TextEncoder().encode(JSON.stringify(authState))))));\n};\n//# sourceMappingURL=parseAuthState.js.map","export var BasedErrorCode;\n(function (BasedErrorCode) {\n    BasedErrorCode[BasedErrorCode[\"FunctionError\"] = 50001] = \"FunctionError\";\n    BasedErrorCode[BasedErrorCode[\"AuthorizeFunctionError\"] = 50002] = \"AuthorizeFunctionError\";\n    BasedErrorCode[BasedErrorCode[\"NoOservableCacheAvailable\"] = 50003] = \"NoOservableCacheAvailable\";\n    BasedErrorCode[BasedErrorCode[\"ObservableFunctionError\"] = 50004] = \"ObservableFunctionError\";\n    BasedErrorCode[BasedErrorCode[\"ObserveCallbackError\"] = 50005] = \"ObserveCallbackError\";\n    BasedErrorCode[BasedErrorCode[\"FunctionNotFound\"] = 40401] = \"FunctionNotFound\";\n    BasedErrorCode[BasedErrorCode[\"FunctionIsNotObservable\"] = 40402] = \"FunctionIsNotObservable\";\n    BasedErrorCode[BasedErrorCode[\"FunctionIsObservable\"] = 40403] = \"FunctionIsObservable\";\n    BasedErrorCode[BasedErrorCode[\"FunctionIsStream\"] = 40404] = \"FunctionIsStream\";\n    BasedErrorCode[BasedErrorCode[\"CannotStreamToObservableFunction\"] = 40405] = \"CannotStreamToObservableFunction\";\n    BasedErrorCode[BasedErrorCode[\"AuthorizeRejectedError\"] = 40301] = \"AuthorizeRejectedError\";\n    BasedErrorCode[BasedErrorCode[\"InvalidPayload\"] = 40001] = \"InvalidPayload\";\n    BasedErrorCode[BasedErrorCode[\"PayloadTooLarge\"] = 40002] = \"PayloadTooLarge\";\n    BasedErrorCode[BasedErrorCode[\"ChunkTooLarge\"] = 40003] = \"ChunkTooLarge\";\n    BasedErrorCode[BasedErrorCode[\"UnsupportedContentEncoding\"] = 40004] = \"UnsupportedContentEncoding\";\n    BasedErrorCode[BasedErrorCode[\"NoBinaryProtocol\"] = 40005] = \"NoBinaryProtocol\";\n    BasedErrorCode[BasedErrorCode[\"LengthRequired\"] = 41101] = \"LengthRequired\";\n    BasedErrorCode[BasedErrorCode[\"MethodNotAllowed\"] = 40501] = \"MethodNotAllowed\";\n    BasedErrorCode[BasedErrorCode[\"RateLimit\"] = 40029] = \"RateLimit\";\n    BasedErrorCode[BasedErrorCode[\"MissingAuthStateProtocolHeader\"] = 40030] = \"MissingAuthStateProtocolHeader\";\n    BasedErrorCode[BasedErrorCode[\"IncorrectAccessKey\"] = 40031] = \"IncorrectAccessKey\";\n})(BasedErrorCode = BasedErrorCode || (BasedErrorCode = {}));\nexport class BasedError extends Error {\n    statusMessage;\n    code;\n}\nexport const convertDataToBasedError = (payload, stack) => {\n    if (!payload || typeof payload !== 'object') {\n        const err = new BasedError(`Payload: ${payload}`);\n        // err.code = BasedErrorCode.FunctionError\n        err.name = 'Invalid returned payload';\n        return err;\n    }\n    const { message, code } = payload;\n    const msg = message\n        ? message[0] === '['\n            ? message\n            : `[${BasedErrorCode[code]}] ` + message\n        : !code\n            ? JSON.stringify(payload, null, 2)\n            : 'Cannot read error msg';\n    const error = new BasedError(msg);\n    error.stack = stack ? msg + ' ' + stack : msg;\n    error.name = BasedErrorCode[code];\n    error.code = code;\n    return error;\n};\n//# sourceMappingURL=error.js.map","import urlLoader from './urlLoader.js';\nimport { encodeAuthState } from '../authState/parseAuthState.js';\nimport { isStreaming } from '../stream/uploadFileBrowser.js';\nimport WebSocket from 'isomorphic-ws';\nconst activityListeners = new Map();\nlet activeTimer;\n// Disconnect in the browser when a window is inactive (on the background) for 30 seconds\nif (typeof document !== 'undefined') {\n    document.addEventListener('visibilitychange', function () {\n        clearTimeout(activeTimer);\n        if (document.hidden) {\n            activeTimer = setTimeout(() => {\n                activityListeners.forEach((fn) => {\n                    fn(false);\n                });\n            }, 30e3);\n        }\n        else {\n            activityListeners.forEach((fn) => {\n                fn(true);\n            });\n        }\n    });\n}\nconst connect = (client, url, connection = {\n    destroy: () => {\n        activityListeners.delete(connection);\n    },\n}, time = 0, reconnect = false) => {\n    urlLoader(url, (realUrl) => {\n        setTimeout(() => {\n            if (connection.disconnected) {\n                return;\n            }\n            let isActive = true;\n            activityListeners.set(connection, (active) => {\n                if (!connection.disconnected) {\n                    if (!active && isActive) {\n                        if (client.functionResponseListeners.size ||\n                            isStreaming.streaming) {\n                            console.warn('Send to background - streams or functions in progress try again in 10 seconds...');\n                            clearTimeout(activeTimer);\n                            activeTimer = setTimeout(() => {\n                                activityListeners.forEach((fn) => {\n                                    fn(false);\n                                });\n                            }, 10e3);\n                        }\n                        else {\n                            console.warn('Send to background - close connection');\n                            isActive = false;\n                            client.onClose();\n                            ws.close();\n                        }\n                    }\n                    else if (!isActive && active) {\n                        activityListeners.delete(connection);\n                        connect(client, url, connection, 0, true);\n                    }\n                }\n            });\n            const ws = (connection.ws = new WebSocket(realUrl, [\n                encodeAuthState(client.authState),\n            ]));\n            let isError = false;\n            ws.binaryType = 'blob';\n            ws.addEventListener('error', (err) => {\n                // TODO: add a websocket close number\n                // also for rateLimit\n                if (err.message && err.message.includes('401')) {\n                    isError = true;\n                }\n            });\n            ws.addEventListener('message', (d) => {\n                client.onData(d);\n            });\n            ws.addEventListener('open', () => {\n                if (isActive) {\n                    if (connection.disconnected) {\n                        return;\n                    }\n                    time = 100;\n                    if (reconnect) {\n                        client.onReconnect();\n                    }\n                    client.onOpen();\n                }\n            });\n            ws.addEventListener('close', () => {\n                if (isActive) {\n                    if (connection.disconnected) {\n                        return;\n                    }\n                    client.onClose();\n                    connect(client, url, connection, \n                    // relatively low backoff but will make it faster if multiple servers are down\n                    isError\n                        ? 5e3\n                        : Math.min(2500, time + ~~(Math.random() * 500) + 100), true);\n                }\n            });\n        }, time);\n    });\n    return connection;\n};\nexport default connect;\n//# sourceMappingURL=index.js.map","export default (url, cb) => {\n    if (typeof url === 'function') {\n        url().then((v) => {\n            cb(v);\n        });\n    }\n    else {\n        cb(url);\n    }\n};\n//# sourceMappingURL=urlLoader.js.map","class Emitter {\n    constructor() {\n        Object.defineProperty(this, 'listeners', {\n            enumerable: false,\n            writable: true,\n        });\n    }\n    listeners = {};\n    emit(type, val) {\n        if (this.listeners[type]) {\n            const lis = this.listeners[type];\n            for (let i = 0, len = lis.length; i < lis.length; i++) {\n                const fn = lis[i];\n                // @ts-ignore\n                fn(val);\n                if (len > lis.length) {\n                    if (lis[i] !== fn) {\n                        i--;\n                        len = lis.length;\n                    }\n                }\n            }\n        }\n    }\n    on(type, fn) {\n        if (!this.listeners[type]) {\n            this.listeners[type] = [];\n        }\n        this.listeners[type].push(fn);\n    }\n    removeAllListeners() {\n        this.listeners = {};\n    }\n    once(type, fn) {\n        if (!fn) {\n            return new Promise((resolve) => {\n                const listener = (v) => {\n                    resolve(v);\n                    this.off(type, listener);\n                };\n                this.on(type, listener);\n            });\n        }\n        const listener = (v) => {\n            fn(v);\n            this.off(type, listener);\n        };\n        this.on(type, listener);\n    }\n    off(type, fn) {\n        const listeners = this.listeners[type];\n        if (listeners) {\n            if (!fn) {\n                delete this.listeners[type];\n            }\n            else {\n                for (let i = 0; i < listeners.length; i++) {\n                    if (listeners[i] === fn) {\n                        listeners.splice(i, 1);\n                        i--;\n                        break;\n                    }\n                }\n                if (listeners.length === 0) {\n                    delete this.listeners[type];\n                }\n            }\n        }\n    }\n}\nexport default Emitter;\n//# sourceMappingURL=Emitter.js.map","import * as fflate from 'fflate';\nconst decoder = new TextDecoder();\nconst encoder = new TextEncoder();\nconst decode = (dataURI) => {\n    const data = global.atob(dataURI);\n    const uncompressed = decoder.decode(fflate.inflateSync(encoder.encode(data)));\n    const parsed = JSON.parse(uncompressed);\n    return parsed;\n};\nexport const removeStorageBrowser = (client, key) => {\n    const prev = localStorage.getItem(key);\n    if (prev) {\n        client.storageSize -= new Blob([prev]).size;\n        localStorage.setItem('@based-size', String(client.storageSize));\n        localStorage.removeItem(key);\n    }\n};\nexport const clearStorageBrowser = () => {\n    const keys = Object.keys(localStorage);\n    try {\n        for (const key of keys) {\n            if (key.startsWith('@based')) {\n                localStorage.removeItem(key);\n            }\n        }\n    }\n    catch (err) {\n        try {\n            localStorage.clear();\n        }\n        catch (err) {\n            console.error(`Based - Error clearing localStorage`);\n        }\n    }\n};\nexport const setStorageBrowser = (client, key, value) => {\n    try {\n        const env = client.storageEnvKey;\n        if (!env) {\n            return;\n        }\n        const prev = localStorage.getItem(key);\n        const stringifiedJson = JSON.stringify(value);\n        const encoded = stringifiedJson.length > 70 || key === '@based-authState-' + env\n            ? global.btoa(decoder.decode(fflate.deflateSync(encoder.encode(stringifiedJson))))\n            : stringifiedJson;\n        const blob = new Blob([encoded]);\n        const size = blob.size;\n        if (prev) {\n            client.storageSize -= new Blob([prev]).size;\n        }\n        client.storageSize += size;\n        if (client.storageSize > client.maxStorageSize) {\n            console.info('Based - Max localStorage size reached - clear');\n            clearStorageBrowser();\n            client.storageSize = 0;\n            if (client.authState.persistent === true) {\n                setStorageBrowser(client, '@based-authState-' + env, client.authState);\n            }\n            client.storageSize += size;\n        }\n        localStorage.setItem('@based-size', String(client.storageSize));\n        localStorage.setItem(key, encoded);\n    }\n    catch (err) {\n        console.error(`Based - Error writing ${key} to localStorage`, err);\n    }\n};\nconst getStorageBrowser = (client, key) => {\n    const env = client.storageEnvKey;\n    if (!env) {\n        return;\n    }\n    try {\n        const value = localStorage.getItem(key);\n        if (value !== undefined) {\n            if (value.length < 70 && key !== '@based-authState-' + env) {\n                try {\n                    return JSON.parse(value);\n                }\n                catch (err) { }\n            }\n            return decode(value);\n        }\n        return;\n    }\n    catch (err) {\n        console.error(`Based - Error parsing ${key} from localStorage`);\n    }\n};\nexport const initStorageBrowser = async (client) => {\n    const env = client.storageEnvKey;\n    if (!env) {\n        return;\n    }\n    const prevCache = global.__basedcache__ ?? {};\n    for (const key in prevCache) {\n        client.cache.set(Number(key), prevCache[key]);\n    }\n    try {\n        // compress as option!\n        let totalSize = Number(localStorage.getItem('@based-size') || 0);\n        if (totalSize < 0) {\n            console.error('Based - Corrupt localStorage (negative size) - clear');\n            clearStorageBrowser();\n            totalSize = 0;\n        }\n        client.storageSize = totalSize;\n        const keys = Object.keys(localStorage);\n        if (keys.length === 1 && totalSize > 0) {\n            console.error('Based - Corrupt localStorage (size but no keys) - clear', totalSize);\n            clearStorageBrowser();\n            totalSize = 0;\n        }\n        console.info(`Based - init localstorage stored ${~~(totalSize / 1024) + 'kb'}`);\n        if (totalSize > 0) {\n            for (const key of keys) {\n                if (key === '@based-size' || !key.startsWith('@based')) {\n                    continue;\n                }\n                if (key === '@based-authState-' + env) {\n                    const authState = getStorageBrowser(client, key);\n                    if (authState) {\n                        client.setAuthState(authState).catch((err) => {\n                            console.error(err.message);\n                            removeStorageBrowser(client, key);\n                        });\n                    }\n                    continue;\n                }\n                const [, keyValuePair] = key.split('@based-cache-');\n                if (!keyValuePair) {\n                    continue;\n                }\n                const [id, e] = keyValuePair.split('-');\n                if (e !== String(env)) {\n                    continue;\n                }\n                if (!id) {\n                    console.warn('Based - clear corrupt localStorage item');\n                    removeStorageBrowser(client, key);\n                    continue;\n                }\n                const value = getStorageBrowser(client, key);\n                client.cache.set(Number(id), value);\n            }\n        }\n    }\n    catch (err) {\n        console.error('Based - Cannot read localStorage');\n    }\n};\n//# sourceMappingURL=browser.js.map","import { initStorageBrowser, setStorageBrowser, removeStorageBrowser, clearStorageBrowser, } from './browser.js';\nconst isBrowser = typeof window !== 'undefined';\nexport const removeStorage = (client, key) => {\n    const env = client.storageEnvKey;\n    if (!env) {\n        return;\n    }\n    if (isBrowser) {\n        key += '-' + env;\n        removeStorageBrowser(client, key);\n    }\n    else if (client.storagePath) {\n        // require('./node').removeStorageNode(client, key)\n    }\n};\nexport const setStorage = (client, key, value) => {\n    const env = client.storageEnvKey;\n    if (!env) {\n        return;\n    }\n    if (isBrowser) {\n        key += '-' + env;\n        setStorageBrowser(client, key, value);\n    }\n    else if (client.storagePath) {\n        // require('./node').setStorageNode(client, key, value)\n    }\n};\nexport const updateStorage = async (client) => {\n    if (isBrowser) {\n        // not nessecary...\n    }\n    else if (client.storagePath) {\n        // return require('./node').store(client)\n    }\n};\nexport const initStorage = async (client) => {\n    if (isBrowser) {\n        return initStorageBrowser(client);\n    }\n    else if (client.storagePath) {\n        // return require('./node').initStorageNode(client)\n    }\n};\nexport const clearStorage = async (client) => {\n    if (isBrowser) {\n        return clearStorageBrowser();\n    }\n    else if (client.storagePath) {\n        // return require('./node').clearStorageNode(client)\n    }\n};\n//# sourceMappingURL=index.js.map","import { setStorage, removeStorage } from '../persistentStorage/index.js';\nexport const updateAuthState = (client, authState) => {\n    if (authState.persistent) {\n        setStorage(client, '@based-authState', authState);\n    }\n    else {\n        removeStorage(client, '@based-authState');\n    }\n    client.authState = authState;\n};\n//# sourceMappingURL=updateAuthState.js.map","import * as fflate from 'fflate';\nconst encoder = new TextEncoder();\nconst storeUint8 = (buff, n, start, len) => {\n    for (let index = start; index < start + len; index++) {\n        const byte = n & 0xff;\n        buff[index] = byte;\n        n = (n - byte) / 256;\n    }\n};\nconst encodeHeader = (type, isDeflate, len) => {\n    // 4 bytes\n    // type (3 bits)\n    //   0 = function\n    //   1 = subscribe\n    //   2 = unsubscribe\n    //   3 = get from observable\n    //   4 = auth\n    //   5 = subscribeChannel\n    //   6 = publishChannel\n    //   7 = unsubscribeChannel\n    // isDeflate (1 bit)\n    // len (28 bits)\n    // @ts-ignore\n    const encodedMeta = (type << 1) + (isDeflate | 0);\n    const nr = (len << 4) + encodedMeta;\n    return nr;\n};\nconst createBuffer = (type, isDeflate, len, size = len) => {\n    const header = encodeHeader(type, isDeflate, len);\n    const buff = new Uint8Array(size);\n    storeUint8(buff, header, 0, 4);\n    return buff;\n};\nconst encodePayload = (payload, noDeflate = false) => {\n    let p;\n    let isDeflate = false;\n    if (payload !== undefined) {\n        p = encoder.encode(typeof payload === 'string' ? payload : JSON.stringify(payload));\n        if (!noDeflate && p.length > 150) {\n            p = fflate.deflateSync(p);\n            isDeflate = true;\n        }\n        return [isDeflate, p];\n    }\n    return [false];\n};\nexport const encodeGetObserveMessage = (id, o) => {\n    let len = 4;\n    const [type, name, checksum, payload] = o;\n    // Type 3 = get\n    // | 4 header | 8 id | 8 checksum | 1 name length | * name | * payload |\n    if (type === 3) {\n        const n = encoder.encode(name);\n        len += 1 + n.length;\n        const [isDeflate, p] = encodePayload(payload);\n        if (p) {\n            len += p.length;\n        }\n        const buffLen = 16;\n        len += buffLen;\n        const buff = createBuffer(type, isDeflate, len, 5 + buffLen);\n        storeUint8(buff, id, 4, 8);\n        storeUint8(buff, checksum, 12, 8);\n        buff[20] = n.length;\n        if (p) {\n            return { buffers: [buff, n, p], len };\n        }\n        else {\n            return { buffers: [buff, n], len };\n        }\n    }\n    return { buffers: [], len: 0 };\n};\nexport const encodeSubscribeChannelMessage = (id, o) => {\n    let len = 4;\n    const [type, name, payload] = o;\n    // Type 5 = subscribe\n    // | 4 header | 8 id | 1 name length | * name | * payload |\n    // Type 7 = unsubscribe\n    // | 4 header | 8 id |\n    if (type === 7) {\n        const buff = createBuffer(type, false, 12);\n        storeUint8(buff, id, 4, 8);\n        return { buffers: [buff], len: 12 };\n    }\n    const n = encoder.encode(name);\n    len += 1 + n.length;\n    const isRequestSubscriber = type === 6;\n    const [, p] = encodePayload(payload, true);\n    if (p) {\n        len += p.length;\n    }\n    const buffLen = 8;\n    len += buffLen;\n    const buff = createBuffer(5, isRequestSubscriber, len, 5 + buffLen);\n    storeUint8(buff, id, 4, 8);\n    buff[12] = n.length;\n    if (p) {\n        return { buffers: [buff, n, p], len };\n    }\n    return { buffers: [buff, n], len };\n};\nexport const encodeObserveMessage = (id, o) => {\n    let len = 4;\n    const [type, name, checksum, payload] = o;\n    // Type 1 = subscribe\n    // | 4 header | 8 id | 8 checksum | 1 name length | * name | * payload |\n    // Type 2 = unsubscribe\n    // | 4 header | 8 id |\n    if (type === 2) {\n        const buff = createBuffer(type, false, 12);\n        storeUint8(buff, id, 4, 8);\n        return { buffers: [buff], len: 12 };\n    }\n    const n = encoder.encode(name);\n    len += 1 + n.length;\n    const [isDeflate, p] = encodePayload(payload);\n    if (p) {\n        len += p.length;\n    }\n    const buffLen = 16;\n    len += buffLen;\n    const buff = createBuffer(type, isDeflate, len, 5 + buffLen);\n    storeUint8(buff, id, 4, 8);\n    storeUint8(buff, checksum, 12, 8);\n    buff[20] = n.length;\n    if (p) {\n        return { buffers: [buff, n, p], len };\n    }\n    return { buffers: [buff, n], len };\n};\nexport const encodeFunctionMessage = (f) => {\n    // | 4 header | 3 id | 1 name length | * name | * payload |\n    let len = 7;\n    const [id, name, payload] = f;\n    const n = encoder.encode(name);\n    len += 1 + n.length;\n    const [isDeflate, p] = encodePayload(payload);\n    if (p) {\n        len += p.length;\n    }\n    const buff = createBuffer(0, isDeflate, len, 8);\n    storeUint8(buff, id, 4, 3);\n    buff[7] = n.length;\n    if (p) {\n        return { buffers: [buff, n, p], len };\n    }\n    return { buffers: [buff, n], len };\n};\nexport const encodePublishMessage = (f) => {\n    // | 4 header | 8 id | * payload |\n    let len = 12;\n    const [id, payload] = f;\n    const [isDeflate, p] = encodePayload(payload);\n    if (p) {\n        len += p.length;\n    }\n    const buff = createBuffer(6, isDeflate, len, 12);\n    storeUint8(buff, id, 4, 8);\n    if (p) {\n        return { buffers: [buff, p], len };\n    }\n    return { buffers: [buff], len };\n};\nexport const encodeAuthMessage = (authState) => {\n    // | 4 header | * payload |\n    let len = 4;\n    const [isDeflate, payload] = encodePayload(authState);\n    if (payload) {\n        len += payload.length;\n    }\n    const buff = createBuffer(4, isDeflate, len);\n    if (payload) {\n        buff.set(payload, 4);\n    }\n    return buff;\n};\n//# sourceMappingURL=protocol.js.map","import { updateAuthState } from '../authState/updateAuthState.js';\nimport { encodeAuthMessage, encodeFunctionMessage, encodeGetObserveMessage, encodeObserveMessage, encodePublishMessage, encodeSubscribeChannelMessage, } from './protocol.js';\nimport { deepEqual } from '@saulx/utils';\nconst PING = new Uint8Array(0);\nexport const idleTimeout = (client) => {\n    const updateTime = 60 * 1e3;\n    clearTimeout(client.idlePing);\n    client.idlePing = setTimeout(() => {\n        if (client.connection &&\n            client.connected &&\n            !client.connection.disconnected) {\n            client.connection.ws.send(PING);\n        }\n    }, updateTime);\n};\nconst hasQueue = (client) => {\n    return !!(client.fQ.length ||\n        client.oQ.size ||\n        client.gQ.size ||\n        client.cQ.size ||\n        client.pQ.length);\n};\nexport const drainQueue = (client) => {\n    if (client.connected && !client.drainInProgress && hasQueue(client)) {\n        client.drainInProgress = true;\n        const drainOutgoing = () => {\n            client.drainInProgress = false;\n            if (!client.connected) {\n                return;\n            }\n            if (hasQueue(client)) {\n                const channel = client.cQ;\n                const publish = client.pQ;\n                const fn = client.fQ;\n                const obs = client.oQ;\n                const get = client.gQ;\n                const buffs = [];\n                let l = 0;\n                // ------- Channel\n                for (const [id, o] of channel) {\n                    const { buffers, len } = encodeSubscribeChannelMessage(id, o);\n                    buffs.push(...buffers);\n                    l += len;\n                }\n                // ------- GetObserve\n                for (const [id, o] of get) {\n                    const { buffers, len } = encodeGetObserveMessage(id, o);\n                    buffs.push(...buffers);\n                    l += len;\n                }\n                // ------- Observe\n                for (const [id, o] of obs) {\n                    const { buffers, len } = encodeObserveMessage(id, o);\n                    buffs.push(...buffers);\n                    l += len;\n                }\n                // ------- Function\n                for (const f of fn) {\n                    const { buffers, len } = encodeFunctionMessage(f);\n                    buffs.push(...buffers);\n                    l += len;\n                }\n                // ------- Publish\n                for (const f of publish) {\n                    const { buffers, len } = encodePublishMessage(f);\n                    buffs.push(...buffers);\n                    l += len;\n                }\n                const n = new Uint8Array(l);\n                let c = 0;\n                for (const b of buffs) {\n                    n.set(b, c);\n                    c += b.length;\n                }\n                client.fQ = [];\n                client.pQ = [];\n                client.oQ.clear();\n                client.gQ.clear();\n                client.cQ.clear();\n                client.connection.ws.send(n);\n                idleTimeout(client);\n            }\n        };\n        client.drainTimeout = setTimeout(drainOutgoing, 0);\n    }\n};\nexport const stopDrainQueue = (client) => {\n    if (client.drainInProgress) {\n        clearTimeout(client.drainTimeout);\n        client.drainInProgress = false;\n    }\n};\n// ------------ Function ---------------\nexport const addToFunctionQueue = (client, payload, name, resolve, reject) => {\n    client.requestId++;\n    // 3 bytes\n    if (client.requestId > 16777215) {\n        client.requestId = 0;\n    }\n    const id = client.requestId;\n    // TODO: When node env is not \"production\" | or when dev\n    const s = Error().stack.split(/BasedClient\\.function.+:\\d\\d\\)/)[1];\n    client.functionResponseListeners.set(id, [resolve, reject, s]);\n    client.fQ.push([id, name, payload]);\n    drainQueue(client);\n};\n// ------------ Channel ---------------\nexport const addChannelCloseToQueue = (client, id) => {\n    const type = client.cQ.get(id)?.[0];\n    if (type === 7) {\n        return;\n    }\n    client.cQ.set(id, [7]);\n    drainQueue(client);\n};\nexport const addChannelSubscribeToQueue = (client, name, id, payload) => {\n    const type = client.cQ.get(id)?.[0];\n    if (type === 5) {\n        return;\n    }\n    client.cQ.set(id, [5, name, payload]);\n    drainQueue(client);\n};\nexport const addChannelPublishIdentifier = (client, name, id, payload) => {\n    const type = client.cQ.get(id)?.[0];\n    if (type === 5 || type === 6) {\n        return;\n    }\n    // if (type === 7) {\n    // unsupported\n    // console.warn(10)\n    // }\n    client.cQ.set(id, [6, name, payload]);\n    drainQueue(client);\n};\nexport const addToPublishQueue = (client, id, payload) => {\n    // TODO: make this configurable at some point\n    if (client.pQ.length > client.maxPublishQueue) {\n        client.pQ.shift();\n    }\n    client.pQ.push([id, payload]);\n    drainQueue(client);\n};\n// ------------ Observable ---------------\nexport const addObsCloseToQueue = (client, id) => {\n    const type = client.oQ.get(id)?.[0];\n    if (type === 2) {\n        return;\n    }\n    client.oQ.set(id, [2]);\n    drainQueue(client);\n};\nexport const addObsToQueue = (client, name, id, payload, checksum = 0) => {\n    const type = client.oQ.get(id)?.[0];\n    if (type === 1) {\n        return;\n    }\n    client.oQ.set(id, [1, name, checksum, payload]);\n    drainQueue(client);\n};\nexport const addGetToQueue = (client, name, id, payload, checksum = 0) => {\n    if (client.gQ.has(id)) {\n        return;\n    }\n    client.gQ.set(id, [3, name, checksum, payload]);\n    drainQueue(client);\n};\n// ------------ Auth ---------------\nexport const sendAuth = async (client, authState) => {\n    if (deepEqual(authState, client.authState)) {\n        console.warn('[Based] Trying to send the same authState twice', client.authState);\n        return client.authRequest.inProgress\n            ? client.authRequest.promise\n            : new Promise((resolve) => resolve({}));\n    }\n    if (client.authRequest.inProgress) {\n        console.warn('[Based] Authentication still in progress - waiting until done');\n        await client.authRequest.promise;\n    }\n    updateAuthState(client, authState);\n    client.emit('authstate-change', client.authState);\n    if (client.connected) {\n        client.connection.ws.send(encodeAuthMessage(authState));\n    }\n    client.authRequest.promise = new Promise((resolve, reject) => {\n        client.authRequest.inProgress = true;\n        client.authRequest.resolve = resolve;\n        client.authRequest.reject = reject;\n        // Gets send in the upgrade header of the websocket\n    }).finally(() => {\n        client.authRequest.resolve = null;\n        client.authRequest.reject = null;\n        client.authRequest.inProgress = false;\n    });\n    return client.authRequest.promise;\n};\n//# sourceMappingURL=index.js.map","import { addGetToQueue } from '../outgoing/index.js';\nexport const decodeHeader = (nr) => {\n    // 4 bytes\n    // type (3 bits)\n    //   0 = functionData\n    //   1 = subscriptionData\n    //   2 = subscriptionDiffData\n    //   3 = get\n    //   4 = authData\n    //   5 = errorData // TODO: make this 7.0 and channelMessage 5\n    //   6 = publish requesChannelName\n    //   7.0 = channelMessage\n    // isDeflate (1 bit)\n    // len (28 bits)\n    const len = nr >> 4;\n    const meta = nr & 15;\n    const type = meta >> 1;\n    const isDeflate = meta & 1;\n    return {\n        type,\n        isDeflate: isDeflate === 1,\n        len,\n    };\n};\nexport const readUint8 = (buff, start, len) => {\n    let n = 0;\n    const s = len - 1 + start;\n    for (let i = s; i >= start; i--) {\n        n = n * 256 + buff[i];\n    }\n    return n;\n};\nexport const parseArrayBuffer = async (d) => {\n    // needed for CF workers which return array buffers\n    if (d instanceof ArrayBuffer) {\n        return new Uint8Array(d);\n    }\n    // can make this in browser / node build\n    if (typeof window === 'undefined') {\n        if (d instanceof Buffer) {\n            return new Uint8Array(d);\n        }\n    }\n    else {\n        if (d instanceof Blob) {\n            const buffer = await d.arrayBuffer();\n            return new Uint8Array(buffer);\n        }\n    }\n    throw new Error('432');\n};\nexport const requestFullData = (client, id) => {\n    const sub = client.observeState.get(id);\n    addGetToQueue(client, sub.name, id, sub.payload);\n};\n//# sourceMappingURL=protocol.js.map","export const getTargetInfo = (client, id, type) => {\n    const sub = type === 'sub' ? client.observeState.get(id) : client.channelState.get(id);\n    if (!sub) {\n        return { name: `[Cannot find ${id}]`, id };\n    }\n    return sub.payload\n        ? { name: sub.name, payload: sub.payload, id }\n        : { name: sub.name, id };\n};\n//# sourceMappingURL=getTargetInfo.js.map","import * as fflate from 'fflate';\n// add diff to the bundle as well\nimport { applyPatch } from '@saulx/diff';\nimport { convertDataToBasedError } from '../types/error.js';\nimport { deepEqual } from '@saulx/utils';\nimport { updateAuthState } from '../authState/updateAuthState.js';\nimport { setStorage } from '../persistentStorage/index.js';\nimport { parseArrayBuffer, decodeHeader, readUint8, requestFullData, } from './protocol.js';\nimport { encodeSubscribeChannelMessage } from '../outgoing/protocol.js';\nimport { getTargetInfo } from '../getTargetInfo.js';\nconst decodeAndDeflate = (start, end, isDeflate, buffer) => {\n    return new TextDecoder().decode(isDeflate\n        ? fflate.inflateSync(buffer.slice(start, end))\n        : buffer.slice(start, end));\n};\nexport const incoming = async (client, data) => {\n    if (client.isDestroyed) {\n        return;\n    }\n    try {\n        const d = data.data;\n        const buffer = await parseArrayBuffer(d);\n        const { type, len, isDeflate } = decodeHeader(readUint8(buffer, 0, 4));\n        // reader for batched replies\n        // ------- Function\n        if (type === 0) {\n            // | 4 header | 3 id | * payload |\n            const id = readUint8(buffer, 4, 3);\n            const start = 7;\n            const end = len + 4;\n            let payload;\n            // if not empty response, parse it\n            if (len !== 3) {\n                payload = JSON.parse(decodeAndDeflate(start, end, isDeflate, buffer));\n            }\n            if (client.functionResponseListeners.has(id)) {\n                client.functionResponseListeners.get(id)[0](payload);\n                client.functionResponseListeners.delete(id);\n            }\n        }\n        // ------- Get checksum is up to date\n        else if (type === 3) {\n            // | 4 header | 8 id |\n            const id = readUint8(buffer, 4, 8);\n            if (client.getState.has(id) && client.cache.has(id)) {\n                const get = client.getState.get(id);\n                for (const [resolve] of get) {\n                    resolve(client.cache.get(id).value);\n                }\n                client.getState.delete(id);\n            }\n        }\n        // ------- Subscription diff data\n        else if (type === 2) {\n            // | 4 header | 8 id | 8 checksum | 8 previousChecksum | * diff |\n            const id = readUint8(buffer, 4, 8);\n            const cachedData = client.cache.get(id);\n            if (!cachedData) {\n                requestFullData(client, id);\n                return;\n            }\n            const checksum = readUint8(buffer, 12, 8);\n            const previousChecksum = readUint8(buffer, 20, 8);\n            if (cachedData.checksum !== previousChecksum) {\n                requestFullData(client, id);\n                return;\n            }\n            const start = 28;\n            const end = len + 4;\n            let diff;\n            // if not empty response, parse it\n            if (len !== 24) {\n                diff = JSON.parse(decodeAndDeflate(start, end, isDeflate, buffer));\n            }\n            try {\n                cachedData.value = applyPatch(cachedData.value, diff);\n                cachedData.checksum = checksum;\n            }\n            catch (err) {\n                requestFullData(client, id);\n                return;\n            }\n            if (client.observeState.has(id)) {\n                const observable = client.observeState.get(id);\n                if (observable.persistent) {\n                    cachedData.persistent = true;\n                    setStorage(client, '@based-cache-' + id, cachedData);\n                }\n                for (const [, handlers] of observable.subscribers) {\n                    handlers.onData(cachedData.value, checksum);\n                }\n            }\n            if (client.getState.has(id)) {\n                const get = client.getState.get(id);\n                for (const [resolve] of get) {\n                    resolve(cachedData.value);\n                }\n                client.getState.delete(id);\n            }\n        }\n        // ------- Subscription data\n        else if (type === 1) {\n            // | 4 header | 8 id | 8 checksum | * payload |\n            const id = readUint8(buffer, 4, 8);\n            const checksum = readUint8(buffer, 12, 8);\n            const start = 20;\n            const end = len + 4;\n            let payload;\n            // If not empty response, parse it\n            if (len !== 16) {\n                payload = JSON.parse(decodeAndDeflate(start, end, isDeflate, buffer));\n            }\n            const cacheData = {\n                value: payload,\n                checksum,\n            };\n            client.cache.set(id, cacheData);\n            if (client.observeState.has(id)) {\n                const observable = client.observeState.get(id);\n                if (observable.persistent) {\n                    cacheData.persistent = true;\n                    setStorage(client, '@based-cache-' + id, cacheData);\n                }\n                for (const [, handlers] of observable.subscribers) {\n                    handlers.onData(payload, checksum);\n                }\n            }\n            if (client.getState.has(id)) {\n                const get = client.getState.get(id);\n                for (const [resolve] of get) {\n                    resolve(payload);\n                }\n                client.getState.delete(id);\n            }\n        }\n        // ------- AuthState\n        else if (type === 4) {\n            // | 4 header | * payload |\n            const start = 4;\n            const end = len + 4;\n            let payload;\n            // if not empty response, parse it\n            if (len !== 3) {\n                payload = JSON.parse(decodeAndDeflate(start, end, isDeflate, buffer));\n            }\n            if (payload === true) {\n                client.authRequest.resolve?.(client.authState);\n            }\n            else if ('error' in payload) {\n                // make a function updateAuthState\n                updateAuthState(client, payload);\n                client.emit('authstate-change', client.authState);\n                client.authRequest.reject?.(new Error(payload.error));\n            }\n            else {\n                if (!deepEqual(client.authState, payload)) {\n                    updateAuthState(client, payload);\n                    client.emit('authstate-change', client.authState);\n                }\n                else {\n                    updateAuthState(client, payload);\n                }\n                client.authRequest?.resolve?.(client.authState);\n            }\n        }\n        // ------- Errors\n        else if (type === 5) {\n            // | 4 header | * payload |\n            const start = 4;\n            const end = len + 4;\n            let payload;\n            // if not empty response, parse it\n            if (len !== 3) {\n                payload = JSON.parse(decodeAndDeflate(start, end, isDeflate, buffer));\n            }\n            if (payload.requestId) {\n                if (client.functionResponseListeners.has(payload.requestId)) {\n                    const [, reject, stack] = client.functionResponseListeners.get(payload.requestId);\n                    reject(convertDataToBasedError(payload, stack));\n                    client.functionResponseListeners.delete(payload.requestId);\n                }\n            }\n            if (payload.channelId) {\n                if (client.channelState.has(payload.channelId)) {\n                    const error = convertDataToBasedError(payload);\n                    const channel = client.channelState.get(payload.channelId);\n                    for (const [, handlers] of channel.subscribers) {\n                        if (handlers.onError) {\n                            handlers.onError(error);\n                        }\n                        else {\n                            console.error(getTargetInfo(client, payload.channelId, 'channel'), error);\n                        }\n                    }\n                }\n            }\n            if (payload.observableId) {\n                client.cache.delete(payload.observableId);\n                if (client.observeState.has(payload.observableId)) {\n                    const error = convertDataToBasedError(payload);\n                    const observable = client.observeState.get(payload.observableId);\n                    for (const [, handlers] of observable.subscribers) {\n                        if (handlers.onError) {\n                            handlers.onError(error);\n                        }\n                        else {\n                            console.error(getTargetInfo(client, payload.observableId, 'sub'), error);\n                        }\n                    }\n                }\n                if (client.getState.has(payload.observableId)) {\n                    const error = convertDataToBasedError(payload);\n                    const get = client.getState.get(payload.observableId);\n                    for (const [, reject] of get) {\n                        // also add stack\n                        reject(error);\n                    }\n                    client.getState.delete(payload.observableId);\n                }\n            }\n        } // ------- Re-Publish send channel name + payload\n        else if (type === 6) {\n            // | 4 header | 8 id | * payload |\n            // get id add last send on the state\n            const id = readUint8(buffer, 4, 8);\n            const channel = client.channelState.get(id);\n            if (id) {\n                if (!channel.inTransit) {\n                    channel.inTransit = true;\n                    const { buffers, len } = encodeSubscribeChannelMessage(id, [\n                        6,\n                        channel.name,\n                        channel.payload,\n                    ]);\n                    const n = new Uint8Array(len);\n                    let c = 0;\n                    for (const b of buffers) {\n                        n.set(b, c);\n                        c += b.length;\n                    }\n                    client.connection.ws.send(n);\n                    if (channel.removeTimer !== -1 && channel.removeTimer < 2) {\n                        channel.removeTimer += 1;\n                    }\n                    setTimeout(() => {\n                        const channel = client.channelState.get(id);\n                        if (channel) {\n                            channel.inTransit = false;\n                        }\n                    }, 5e3);\n                }\n                client.connection.ws.send(buffer);\n            }\n        } // ----------- Channel message\n        else if (type === 7) {\n            // | 4 header | 1 subType |\n            const subType = readUint8(buffer, 4, 1);\n            if (subType === 0) {\n                // | 4 header | 1 subType | 8 id | * payload |\n                const id = readUint8(buffer, 5, 8);\n                const start = 13;\n                const end = len + 5;\n                let payload;\n                // if not empty response, parse it\n                if (len !== 9) {\n                    const r = decodeAndDeflate(start, end, isDeflate, buffer);\n                    try {\n                        payload = JSON.parse(r);\n                    }\n                    catch (err) {\n                        payload = r;\n                    }\n                }\n                if (client.channelState.has(id)) {\n                    const observable = client.channelState.get(id);\n                    for (const [, handlers] of observable.subscribers) {\n                        handlers.onMessage(payload);\n                    }\n                }\n            }\n        }\n        // ---------------------------------\n    }\n    catch (err) {\n        // just code can load error codes as well\n        // 981 - cannot parse data\n        console.error(981, err);\n    }\n};\n//# sourceMappingURL=index.js.map","import { hashObjectIgnoreKeyOrder, hash } from '@saulx/hash';\nexport const genObserveId = (name, payload) => {\n    if (payload === undefined) {\n        return hash(name);\n    }\n    return hashObjectIgnoreKeyOrder([name, payload]);\n};\n//# sourceMappingURL=genObserveId.js.map","import { addObsToQueue, addObsCloseToQueue, addGetToQueue, } from '../outgoing/index.js';\nimport { genObserveId } from '../genObserveId.js';\nimport { removeStorage, setStorage } from '../persistentStorage/index.js';\n// Can extend this as a query builder\n// TODO: maybe add user bound as option (will clear / set on a-state chage)\nexport class BasedQuery {\n    id;\n    query;\n    name;\n    client;\n    persistent;\n    constructor(client, name, payload, opts) {\n        this.query = payload;\n        this.id = genObserveId(name, payload);\n        this.client = client;\n        this.name = name;\n        this.persistent = opts?.persistent || false;\n    }\n    get cache() {\n        return this.client.cache.get(this.id) || null;\n    }\n    clearCache() {\n        if (this.persistent) {\n            removeStorage(this.client, '@based-cache-' + this.id);\n        }\n        this.client.cache.delete(this.id);\n    }\n    subscribe(onData, onError) {\n        let subscriberId;\n        const cachedData = this.client.cache.get(this.id);\n        if (!this.client.observeState.has(this.id)) {\n            subscriberId = 1;\n            const subscribers = new Map();\n            subscribers.set(subscriberId, {\n                onError,\n                onData,\n            });\n            this.client.observeState.set(this.id, {\n                payload: this.query,\n                name: this.name,\n                subscribers,\n                persistent: this.persistent || false,\n                idCnt: 1,\n            });\n            addObsToQueue(this.client, this.name, this.id, this.query, cachedData?.checksum || 0);\n        }\n        else {\n            const obs = this.client.observeState.get(this.id);\n            if (this.persistent && !obs.persistent) {\n                obs.persistent = true;\n                if (cachedData) {\n                    setStorage(this.client, '@based-cache-' + this.id, cachedData);\n                }\n            }\n            subscriberId = ++obs.idCnt;\n            obs.subscribers.set(subscriberId, {\n                onError,\n                onData,\n            });\n        }\n        if (cachedData) {\n            onData(cachedData.value, cachedData.checksum);\n        }\n        return () => {\n            const obs = this.client.observeState.get(this.id);\n            if (obs) {\n                obs.subscribers.delete(subscriberId);\n                if (obs.subscribers.size === 0) {\n                    this.client.observeState.delete(this.id);\n                    addObsCloseToQueue(this.client, this.id);\n                }\n            }\n            else {\n                console.warn('Subscription allready removed', this.query, this.name);\n            }\n        };\n    }\n    async getWhen(condition) {\n        return new Promise((resolve) => {\n            const close = this.subscribe((data, checksum) => {\n                if (condition(data, checksum)) {\n                    resolve(data);\n                    close();\n                }\n            });\n        });\n    }\n    async get() {\n        return new Promise((resolve, reject) => {\n            if (this.client.getState.has(this.id)) {\n                this.client.getState.get(this.id).push([resolve, reject]);\n                return;\n            }\n            this.client.getState.set(this.id, []);\n            const cachedData = this.client.cache.get(this.id);\n            if (this.client.observeState.has(this.id)) {\n                if (this.client.oQ.has(this.id)) {\n                    const [type] = this.client.oQ.get(this.id);\n                    if (type === 1) {\n                        this.client.getState.get(this.id).push([resolve, reject]);\n                        return;\n                    }\n                }\n                if (cachedData) {\n                    resolve(cachedData.value);\n                    return;\n                }\n            }\n            this.client.getState.get(this.id).push([resolve, reject]);\n            addGetToQueue(this.client, this.name, this.id, this.query, cachedData?.checksum || 0);\n        });\n    }\n}\n//# sourceMappingURL=index.js.map","export const cleanUpChannels = (client) => {\n    if (!client.channelCleanTimeout) {\n        client.channelCleanTimeout = setTimeout(() => {\n            client.channelCleanTimeout = null;\n            if (client.connected) {\n                let keepRunning = false;\n                client.channelState.forEach((value, key) => {\n                    if (value.removeTimer !== -1) {\n                        value.removeTimer--;\n                        if (value.removeTimer === 0) {\n                            client.channelState.delete(key);\n                        }\n                        else {\n                            keepRunning = true;\n                        }\n                    }\n                });\n                if (keepRunning) {\n                    cleanUpChannels(client);\n                }\n            }\n            else {\n                cleanUpChannels(client);\n            }\n        }, client.channelCleanupCycle);\n    }\n};\n//# sourceMappingURL=cleanUp.js.map","import { genObserveId } from '../genObserveId.js';\nimport { addChannelCloseToQueue, addChannelPublishIdentifier, addChannelSubscribeToQueue, addToPublishQueue, } from '../outgoing/index.js';\nimport { cleanUpChannels } from './cleanUp.js';\nexport class BasedChannel {\n    id;\n    payload;\n    name;\n    client;\n    constructor(client, name, payload) {\n        this.payload = payload;\n        this.id = genObserveId(name, payload);\n        this.client = client;\n        this.name = name;\n    }\n    subscribe(onMessage, onError) {\n        let subscriberId;\n        if (!this.client.channelState.has(this.id) ||\n            this.client.channelState.get(this.id).subscribers.size === 0) {\n            subscriberId = 1;\n            const subscribers = new Map();\n            subscribers.set(subscriberId, { onMessage, onError });\n            this.client.channelState.set(this.id, {\n                payload: this.payload,\n                name: this.name,\n                subscribers,\n                removeTimer: -1,\n                idCnt: 1,\n            });\n            addChannelSubscribeToQueue(this.client, this.name, this.id, this.payload);\n        }\n        else {\n            const channel = this.client.channelState.get(this.id);\n            channel.removeTimer = -1;\n            subscriberId = ++channel.idCnt;\n            channel.subscribers.set(subscriberId, { onMessage, onError });\n        }\n        return () => {\n            const channel = this.client.channelState.get(this.id);\n            channel.subscribers.delete(subscriberId);\n            if (channel.subscribers.size === 0) {\n                channel.removeTimer = 2;\n                addChannelCloseToQueue(this.client, this.id);\n            }\n        };\n    }\n    publish(message) {\n        if (!this.client.channelState.has(this.id)) {\n            // This is a perf optmization to not send payload + name\n            this.client.channelState.set(this.id, {\n                payload: this.payload,\n                name: this.name,\n                subscribers: new Map(),\n                removeTimer: 2,\n                idCnt: 0,\n            });\n            cleanUpChannels(this.client);\n            addChannelPublishIdentifier(this.client, this.name, this.id, this.payload);\n        }\n        else {\n            const channel = this.client.channelState.get(this.id);\n            if (channel.removeTimer !== -1 && channel.removeTimer < 2) {\n                channel.removeTimer = 2; // 2x 30sec\n                cleanUpChannels(this.client);\n            }\n        }\n        addToPublishQueue(this.client, this.id, message);\n    }\n}\n//# sourceMappingURL=index.js.map","import connectWebsocket from './websocket/index.js';\nimport Emitter from './Emitter.js';\nimport { addChannelPublishIdentifier, addChannelSubscribeToQueue, addObsToQueue, addToFunctionQueue, drainQueue, sendAuth, } from './outgoing/index.js';\nimport { incoming } from './incoming/index.js';\nimport { BasedQuery } from './query/index.js';\nimport startStream from './stream/index.js';\nimport { initStorage, clearStorage, updateStorage, } from './persistentStorage/index.js';\nimport { BasedChannel } from './channel/index.js';\nimport { hashObjectIgnoreKeyOrder } from '@saulx/hash';\nimport { deepEqual } from '@saulx/utils';\nimport basedOptsPkg from '@based/opts';\nconst parseOpts = basedOptsPkg.default;\nexport * from './authState/parseAuthState.js';\nexport * from './types/error.js';\nexport { BasedQuery };\nexport class BasedClient extends Emitter {\n    constructor(opts, settings) {\n        super();\n        if (settings?.persistentStorage) {\n            this.storagePath = settings.persistentStorage;\n        }\n        if (settings?.maxCacheSize) {\n            console.warn('MaxCacheSize setting not implemented yet...');\n            this.maxCacheSize = settings.maxCacheSize;\n        }\n        if (opts) {\n            this.connect(opts);\n        }\n    }\n    // --------- Persistent Storage\n    storageSize = 0;\n    maxStorageSize = 5e6 - 500; // ~5mb\n    storageEnvKey = 0;\n    storagePath;\n    storageBeingWritten;\n    // --------- Connection State\n    opts;\n    connected = false;\n    connection;\n    url;\n    // --------- Stream\n    outgoingStreams = new Map();\n    isDrainingStreams = false;\n    // --------- Queue\n    maxPublishQueue = 1000;\n    pQ = [];\n    fQ = [];\n    oQ = new Map();\n    cQ = new Map();\n    gQ = new Map();\n    drainInProgress = false;\n    drainTimeout;\n    idlePing;\n    // --------- Cache State\n    localStorage = false;\n    maxCacheSize = 4e6; // in bytes\n    cache = new Map();\n    // --------- Function State\n    functionResponseListeners = new Map();\n    requestId = 0; // max 3 bytes (0 to 16777215)\n    // --------- Channel State\n    channelState = new Map();\n    channelCleanTimeout;\n    channelCleanupCycle = 30e3;\n    // --------- Observe State\n    observeState = new Map();\n    // --------- Get State\n    getState = new Map();\n    // -------- Auth state\n    authState = {};\n    authRequest = {\n        authState: null,\n        promise: null,\n        resolve: null,\n        reject: null,\n        inProgress: false,\n    };\n    // --------- Internal Events\n    onClose() {\n        this.connected = false;\n        // Rare edge case where server got dc'ed while sending the queue - before recieving result)\n        if (this.functionResponseListeners.size > this.fQ.length) {\n            this.functionResponseListeners.forEach((p, k) => {\n                if (!this.fQ.find(([id]) => {\n                    if (id === k) {\n                        return true;\n                    }\n                    return false;\n                })) {\n                    p[1](new Error(`Server disconnected before function result was processed`));\n                    this.functionResponseListeners.delete(k);\n                }\n            });\n        }\n        this.emit('disconnect', true);\n    }\n    onReconnect() {\n        this.connected = true;\n        this.emit('reconnect', true);\n    }\n    onOpen() {\n        this.connected = true;\n        this.emit('connect', true);\n        // Resend all subscriptions\n        for (const [id, obs] of this.observeState) {\n            if (!this.oQ.has(id)) {\n                const cachedData = this.cache.get(id);\n                addObsToQueue(this, obs.name, id, obs.payload, cachedData?.checksum || 0);\n            }\n        }\n        // Resend all channels\n        for (const [id, channel] of this.channelState) {\n            if (!this.cQ.has(id)) {\n                if (channel.subscribers.size) {\n                    addChannelSubscribeToQueue(this, channel.name, id, channel.payload);\n                }\n                else {\n                    addChannelPublishIdentifier(this, channel.name, id, channel.payload);\n                }\n            }\n        }\n        drainQueue(this);\n    }\n    onData(data) {\n        incoming(this, data);\n    }\n    // --------- Connect\n    /**\n    Connect to a server or based cluster\n    \n    ```javascript\n    // Connects to a specific based server\n    client.connect({\n      url: 'ws://localhost:9910'\n    })\n  \n    // Connects to an environment in the based cloud\n    client.connect({\n      org: 'saulx',\n      project: 'demo',\n      env: 'production'\n    })\n    ```\n     */\n    async connect(opts) {\n        if (opts && Object.keys(opts).length > 0) {\n            if (this.opts) {\n                if (deepEqual(this.opts, opts)) {\n                    return;\n                }\n                this.disconnect();\n            }\n            this.opts = opts;\n            this.url = () => parseOpts(opts);\n            this.storageEnvKey = hashObjectIgnoreKeyOrder(opts);\n            initStorage(this);\n        }\n        if (!this.opts) {\n            console.error('Configure opts to connect');\n            return;\n        }\n        if (this.url && !this.connection) {\n            this.connection = connectWebsocket(this, this.url);\n        }\n    }\n    /**\n    Disconnect the client\n    \n    ```javascript\n    client.disconnect()\n    ```\n     */\n    disconnect() {\n        if (this.connection) {\n            this.connection.disconnected = true;\n            this.connection.destroy();\n            if (this.connection.ws) {\n                this.connection.ws.close();\n            }\n            if (this.connected) {\n                this.onClose();\n            }\n            delete this.connection;\n        }\n        clearTimeout(this.drainTimeout);\n        clearTimeout(this.idlePing);\n        this.connected = false;\n    }\n    // ---------- Destroy\n    isDestroyed;\n    /**\n    Destroy the client, will remove all internals and cannot be resued,\n    will update localStorage with the all `persistent` queries in memory\n    \n    ```javascript\n    await client.destroy()\n  \n    // Do not update localStorage with current state\n    await client.destroy(true)\n    ```\n     */\n    async destroy(noStorage) {\n        if (!noStorage) {\n            await updateStorage(this);\n        }\n        clearTimeout(this.storageBeingWritten);\n        clearTimeout(this.channelCleanTimeout);\n        this.disconnect();\n        for (const i in this) {\n            delete this[i];\n        }\n        this.isDestroyed = true;\n    }\n    // ---------- Channel\n    /**\n    Subscribe or publish to a channel, channels are stateless\n    \n    ```javascript\n    client.channel('events', { type: 'pageview' })\n      .subscribe(event => console.info(event))\n  \n    client.channel('events', { type: 'pageview' })\n      .publish({ path: '/home' })\n    ```\n     */\n    channel(name, payload) {\n        return new BasedChannel(this, name, payload);\n    }\n    // ---------- Query\n    /**\n    Query, subscribe or get from a query function, query functions keep their current state memcached\n    \n    ```javascript\n    // Receive updates\n    client.query('db', {\n      $id: 'userid',\n      posts: true\n    }).subscribe(data => console.info(data))\n  \n    // Receive updates, and store in localStorage\n    client.query('db', {\n      $id: 'userid',\n      posts: true\n    }, { persistent: true })\n      .subscribe(data => console.info(data))\n  \n    // Get the current state of a user\n    await client.query('db', {\n      $id: 'userid',\n      email: true\n    }).get()\n    ```\n    */\n    query(name, payload, opts) {\n        return new BasedQuery(this, name, payload, opts);\n    }\n    // -------- Function\n    /**\n    Callable function, mostly used for modifications.\n    */\n    call(name, payload, opts) {\n        const retryStrategy = opts?.retryStrategy;\n        if (retryStrategy) {\n            return new Promise((resolve) => {\n                let time = 0;\n                let retries = 0;\n                const retryReject = (err) => {\n                    const newTime = retryStrategy(err, time, retries);\n                    retries++;\n                    if (typeof newTime === 'number' && !isNaN(newTime)) {\n                        time = newTime;\n                        if (newTime === 0) {\n                            addToFunctionQueue(this, payload, name, resolve, retryReject);\n                        }\n                        else {\n                            setTimeout(() => {\n                                addToFunctionQueue(this, payload, name, resolve, retryReject);\n                            }, newTime);\n                        }\n                    }\n                };\n                return addToFunctionQueue(this, payload, name, resolve, retryReject);\n            });\n        }\n        else {\n            return new Promise((resolve, reject) => {\n                return addToFunctionQueue(this, payload, name, resolve, reject);\n            });\n        }\n    }\n    // -------- Stream\n    /**\n    Stream large payload to a `stream-function`\n    \n    ```javascript\n    await client.stream('db:file', file)\n    ```\n    */\n    stream(name, stream, progressListener) {\n        return startStream(this, name, stream, progressListener);\n    }\n    // -------- Auth\n    /**\n    Set auth state on client and server, `persistent`\n    will keep the authState in localStorage\n    \n    ```javascript\n    await client.setAuthState({ token: 'token', persistent: true })\n    ```\n    */\n    setAuthState(authState) {\n        if (typeof authState === 'object') {\n            return sendAuth(this, authState);\n        }\n        else {\n            throw new Error('Invalid auth() arguments');\n        }\n    }\n    /**\n    Removes the current authState on server and client\n    \n    ```javascript\n    await client.clearAuthState()\n    ```\n    */\n    clearAuthState() {\n        return sendAuth(this, {});\n    }\n    // -------- Storage layer\n    /**\n    Clear localStorage (removes storage file if configured for node.js)\n    \n    ```javascript\n    await client.clearStorage()\n    ```\n    */\n    clearStorage() {\n        return clearStorage(this);\n    }\n    /**\n    Save current state of all cached query functions that have `persistent` set to true\n    \n    ```javascript\n    await client.saveStorage()\n    ```\n    */\n    saveStorage() {\n        return updateStorage(this);\n    }\n    genCacheScript() {\n        return `<script>window.__basedcache__=${JSON.stringify(genCacheObject(this))}</script>`;\n    }\n}\nconst genCacheObject = (client) => {\n    const m = {};\n    client.cache.forEach((v, k) => {\n        m[k] = v;\n    });\n    return m;\n};\n/**\n  Creates a based client\n  \n  ```javascript\n  // Connects to a specific based server\n  const client = based({\n    url: 'ws://localhost:9910'\n  })\n\n  // Connects to an environment in the based cloud\n  const client = based({\n    org: 'saulx',\n    project: 'demo',\n    env: 'production'\n  })\n  ```\n*/\nexport default function based(opts, settings) {\n    return new BasedClient(opts, settings);\n}\n//# sourceMappingURL=index.js.map","// import uploadFileBrowser from './uploadFileBrowser'\n// import fetch from './fetch'\n// const isBrowser = typeof window !== 'undefined'\n// const isStream = (stream: any): boolean => {\n//   return (\n//     stream !== null &&\n//     typeof stream === 'object' &&\n//     typeof stream.pipe === 'function' &&\n//     stream.readable !== false &&\n//     typeof stream._read === 'function' &&\n//     typeof stream._readableState === 'object'\n//   )\n// }\n// const isStreamFunctionPath = (\n//   options: StreamFunctionOpts\n// ): options is StreamFunctionPath => {\n//   return 'path' in options && typeof options.path === 'string'\n// }\n// const isStreamFunctionStream = (\n//   options: StreamFunctionOpts\n// ): options is StreamFunctionStream => {\n//   return 'contents' in options && isStream(options.contents)\n// }\n// export default async (\n//   client: BasedClient,\n//   name: string,\n//   options: StreamFunctionOpts,\n//   progressListener?: (progress: number) => void\n// ): Promise<any> => {\n//   if (isStreamFunctionPath(options)) {\n//     if (isBrowser) {\n//       throw new Error('File path not supported in the browser')\n//     }\n//     // not for browser! hope this is enough for most builders...\n//     return require('./nodeStream').uploadFilePath(client, name, options)\n//   }\n//   if (isStreamFunctionStream(options)) {\n//     if (isBrowser) {\n//       throw new Error('Node streams not supported in the browser')\n//     }\n//     // not for browser! hope this is enough for most builders...\n//     return require('./nodeStream').uploadFileStream(client, name, options)\n//   }\n//   if (options.contents instanceof ArrayBuffer) {\n//     options.contents = isBrowser\n//       ? new global.Blob([options.contents], {\n//           type: options.mimeType || 'text/plain',\n//         })\n//       : global.Buffer.from(options.contents)\n//     // want to stream this XHR browser / stream + http nodejs\n//     return fetch(client, name, options)\n//   }\n//   if (isBrowser && isFileContents(options)) {\n//     return uploadFileBrowser(client, name, options, progressListener)\n//   }\n//   if (isBrowser && options.contents instanceof global.Blob) {\n//     if (!options.mimeType) {\n//       options.mimeType = options.contents.type\n//     }\n//     // want to stream this XHR browser / stream + http nodejs\n//     return fetch(client, name, options)\n//   }\n//   if (\n//     typeof options.contents === 'string' ||\n//     (!isBrowser && options.contents instanceof global.Buffer)\n//   ) {\n//     // want to stream this XHR browser / stream + http nodejs\n//     return fetch(client, name, options)\n//   }\n//   throw new Error(\n//     `Invalid opts for file api ${name} ${JSON.stringify(options, null, 2)}`\n//   )\n// }\nexport default async (_client, _name, _options, _progressListener) => { };\n//# sourceMappingURL=index.js.map"],"names":["decodeAuthState","authState","str","global","atob","decodeURI","JSON","parse","err","error","encode","createEncoder","encodeAuthState","encodeURI","btoa","String","fromCodePoint","TextEncoder","stringify","BasedErrorCode","BasedError","Error","convertDataToBasedError","payload","stack","name","message","code","msg","activityListeners","Map","activeTimer","document","addEventListener","clearTimeout","hidden","setTimeout","forEach","fn","connect","client","url","connection","destroy","delete","time","reconnect","cb","then","v","urlLoader","realUrl","disconnected","isActive","set","active","functionResponseListeners","size","console","warn","onClose","ws","close","WebSocket","isError","binaryType","includes","d","onData","onReconnect","onOpen","Math","min","random","Emitter","constructor","this","listeners","Object","defineProperty","enumerable","writable","emit","type","val","lis","i","len","length","on","push","removeAllListeners","once","Promise","resolve","listener","off","splice","decoder","TextDecoder","encoder","removeStorageBrowser","key","prev","localStorage","getItem","storageSize","Blob","setItem","removeItem","clearStorageBrowser","keys","startsWith","clear","setStorageBrowser","value","env","storageEnvKey","stringifiedJson","encoded","decode","fflate","deflateSync","maxStorageSize","info","persistent","getStorageBrowser","undefined","dataURI","data","uncompressed","inflateSync","parsed","isBrowser","window","removeStorage","setStorage","updateStorage","async","updateAuthState","storeUint8","buff","n","start","index","byte","createBuffer","isDeflate","header","encodeHeader","Uint8Array","encodePayload","noDeflate","p","encodeGetObserveMessage","id","o","checksum","buffLen","buffers","encodeSubscribeChannelMessage","isRequestSubscriber","encodeObserveMessage","encodeFunctionMessage","f","encodePublishMessage","PING","hasQueue","fQ","oQ","gQ","cQ","pQ","drainQueue","connected","drainInProgress","drainOutgoing","channel","publish","obs","get","buffs","l","c","b","send","idlePing","idleTimeout","drainTimeout","addToFunctionQueue","reject","requestId","s","split","addChannelSubscribeToQueue","_client$cQ$get2","addChannelPublishIdentifier","_client$cQ$get3","addObsToQueue","_client$oQ$get2","addGetToQueue","has","sendAuth","deepEqual","authRequest","inProgress","promise","encodeAuthMessage","finally","readUint8","requestFullData","sub","observeState","getTargetInfo","channelState","decodeAndDeflate","end","buffer","slice","genObserveId","hash","hashObjectIgnoreKeyOrder","BasedQuery","opts","query","cache","clearCache","subscribe","onError","subscriberId","cachedData","idCnt","subscribers","addObsCloseToQueue","_client$oQ$get","getWhen","condition","getState","cleanUpChannels","channelCleanTimeout","keepRunning","removeTimer","channelCleanupCycle","BasedChannel","onMessage","addChannelCloseToQueue","_client$cQ$get","addToPublishQueue","maxPublishQueue","shift","parseOpts","basedOptsPkg","default","BasedClient","settings","super","outgoingStreams","isDrainingStreams","maxCacheSize","persistentStorage","storagePath","k","find","isDestroyed","ArrayBuffer","Buffer","arrayBuffer","parseArrayBuffer","nr","meta","decodeHeader","previousChecksum","diff","applyPatch","observable","handlers","cacheData","_client$authRequest","channelId","observableId","inTransit","r","incoming","disconnect","_global$__basedcache_","prevCache","__basedcache__","Number","totalSize","setAuthState","catch","keyValuePair","e","initStorageBrowser","initStorage","connectWebsocket","noStorage","storageBeingWritten","call","retryStrategy","retries","retryReject","newTime","isNaN","stream","progressListener","_client","_name","_options","_progressListener","startStream","clearAuthState","clearStorage","saveStorage","genCacheScript","genCacheObject","m","based"],"mappings":"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"}